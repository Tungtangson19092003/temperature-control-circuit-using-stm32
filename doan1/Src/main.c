/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2024 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include <stdio.h>

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif
#define ENABLE                          1
#define DISABLE                         0

#define I2C_SCL_SPEED_SM 100000U

#define I2C_FLAG_OVR                    (1 << 11)
#define I2C_FLAG_AF                     (1 << 10)
#define I2C_FLAG_ARLO                   (1 << 9)
#define I2C_FLAG_BERR                   (1 << 8)
#define I2C_FLAG_TXE                    (1 << 7)
#define I2C_FLAG_RXNE                   (1 << 6)
#define I2C_FLAG_STOPF                  (1 << 4)
#define I2C_FLAG_ADD10                  (1 << 3)
#define I2C_FLAG_BTF                    (1 << 2)
#define I2C_FLAG_ADDR                   (1 << 1)
#define I2C_FLAG_SB                     (1 << 0)

//trigger measurement byte plus 2 bytes
uint8_t AHT10_command[3]={0xAC,0x33,0x00};
//array stores 10 values
float array[10]={0,0,0,0,0,0,0,0,0,0};

uint16_t AHB_Prescaler[8]={2,4,8,16,64,128,256,512};
uint16_t APB_Prescaler[4]={2,4,8,16};

typedef struct
{
	uint32_t CRL;
	uint32_t CRH;
	uint32_t IDR;
	uint32_t ODR;
	uint32_t BSRR;
	uint32_t BRR;
	uint32_t LCKR;
}GPIO_RedDef_t;
GPIO_RedDef_t*pGPIOB=(GPIO_RedDef_t*)0x40010C00;

typedef struct
{
	uint32_t CR1;
	uint32_t CR2;
	uint32_t OAR1;
	uint32_t OAR2;
	uint32_t DR;
	uint32_t SR1;
	uint32_t SR2;
	uint32_t CCR;
	uint32_t TRISE;
}I2C1_RedDef_t;
I2C1_RedDef_t*pI2C1=(I2C1_RedDef_t*)0x40005400;

typedef struct
{
	uint32_t CR;
	uint32_t CFGR;
	uint32_t CIR;
	uint32_t APB2RSTR;
	uint32_t APB1RSTR;
	uint32_t AHBENR;
	uint32_t APB2ENR;
	uint32_t APB1ENR;
	uint32_t BDCR;
	uint32_t CSR;
}RCC_RedDef_t;
RCC_RedDef_t*pRCC=(RCC_RedDef_t*)0x40021000;

void delay(){
	for(uint32_t i=0; i < 30000;i++);
}

uint32_t RCC_GetPCKLValue(void)
{
uint32_t pclk,sclk;
uint8_t clksrc,temp,ahbp,apb1p;
clksrc=((pRCC->CFGR>>2) & 0x3);
if( clksrc==0)
	sclk=8000000;//HSI
temp=((pRCC->CFGR>>4) & 0xf);
if(temp<8){
	ahbp=1;
}
else{
	ahbp=AHB_Prescaler[temp-8];
}
temp=((pRCC->CFGR>>8) & 0x7);
if(temp<4){
	apb1p=1;
}
else{
	apb1p=APB_Prescaler[temp-4];
}
pclk=(sclk/ahbp)/apb1p;
return pclk;
}

void I2C_PeripheralControl(I2C1_RedDef_t*pI2Cx,uint8_t enordi){
	if(enordi==ENABLE){
	    pI2Cx->CR1|=(1<<0);
		}else{
	    pI2Cx->CR1&=~(1<<0);
		}
}

void I2C_ClearADDRFlag(I2C1_RedDef_t*pI2Cx){
	uint32_t read=pI2Cx->SR1;
	read=pI2Cx->SR2;
	(void)read;
}

uint8_t I2C_GetFlagStatus(I2C1_RedDef_t*pI2Cx,uint32_t Flagname){
	if(pI2Cx->SR1 & Flagname){
		return 1;
	}else{
		return 0;
	}
}

void I2C_ExecuteAddressPhaseRead(I2C1_RedDef_t*pI2Cx,uint8_t SlaveAddr){
	SlaveAddr=SlaveAddr << 1;
	SlaveAddr|=1;//SlaveAddr is Slave address + R/nW=1
	pI2Cx->DR=SlaveAddr;
}

void I2C_ExecuteAddressPhaseWrite(I2C1_RedDef_t*pI2Cx,uint8_t SlaveAddr){
	SlaveAddr=SlaveAddr << 1;
	SlaveAddr&=~1;//SlaveAddr is Slave address + R/nW=0
	pI2Cx->DR=SlaveAddr;
}

void I2C_GenerateStartCondition(I2C1_RedDef_t*pI2Cx){
	pI2Cx->CR1|=(1<<8);
}

void I2C_GenerateStoptCondition(I2C1_RedDef_t*pI2Cx){
	pI2Cx->CR1|=(1<<9);
}

void I2C_ManageAcking(I2C1_RedDef_t*pI2Cx,uint8_t enordi){
	if(enordi==ENABLE){
		pI2Cx->CR1|=(1<<10);
	}else{
		pI2Cx->CR1&=~(1<<10);
	}
}

void Init(){

       //enble clock for GPIOB
	   pRCC->APB2ENR|=(1<<3);

	   pGPIOB->CRH |=(3<<4);//pb9 output 50mhz
	   pGPIOB->CRH &=(~(3<<6));//pb9 output push-pull

	   //enble clock for GPIOB
	   pRCC->APB1ENR|=(1<<21);

	   pGPIOB->CRL &=~(3<<24);//clear
	   pGPIOB->CRL |=(1<<24);//pb6 output 10mhz
	   pGPIOB->CRL |=(3<<26);//pb6 output alt SCL

	   pGPIOB->CRL &=~(3<<28);//clear
	   pGPIOB->CRL |=(1<<28);//pb7 output 10mhz
	   pGPIOB->CRL |=(3<<30);//pb7 output alt SDA

	  I2C_ManageAcking(pI2C1,ENABLE);// ACK on

	  pI2C1->CR2|=(RCC_GetPCKLValue()/1000000u);//config the FREQ of CR2

	  //calculate CCR for the standard mode
	  uint16_t ccr_value=0;
	  uint8_t tempreg1=0;
	  ccr_value=RCC_GetPCKLValue()/(2*I2C_SCL_SPEED_SM);
	  tempreg1=(ccr_value &  0xfff);
	  pI2C1->CCR|=tempreg1;

	  // config TRISE
	  uint16_t tempreg2=0;
	  tempreg2=(RCC_GetPCKLValue()/1000000u)+1;
	  pI2C1->TRISE|=(tempreg2 & 0x3f);
}

void GPIO_FanOn(GPIO_RedDef_t*pGPIOx){
	pGPIOx->ODR|=(1<<9);
}

void GPIO_FanOff(GPIO_RedDef_t*pGPIOx){
	pGPIOx->ODR&=(~(1<<9));
}

void I2C_MasterSendData(I2C1_RedDef_t*pI2Cx,uint8_t *pTxBuffer,uint8_t len,uint8_t SlaveAddr){
	//1.generate the start condition
	I2C_GenerateStartCondition(pI2Cx);
	//2.confirm the start condition was completed by SB flag
	while(!I2C_GetFlagStatus(pI2Cx,I2C_FLAG_SB ));
	//3.send the address of slave + R/nW
	I2C_ExecuteAddressPhaseWrite(pI2Cx,SlaveAddr);
	//4.confirm address phase was completed by ADDR flag
	while(!I2C_GetFlagStatus(pI2Cx,I2C_FLAG_ADDR ));
	//5.clear the ADDR fag
	I2C_ClearADDRFlag(pI2Cx);
	//6.send the data until len=0
	while(len>0){
		// wait until TXE=1
		while(!I2C_GetFlagStatus(pI2Cx,I2C_FLAG_TXE ));
		//write data from data resgister to buffer
		pI2Cx->DR=*pTxBuffer;
		// increase the buffer's adddress
		pTxBuffer++;
		len--;
	}
	//7.when len=0 , wait TXE=1 and BTF=1 before STOP
	while(!I2C_GetFlagStatus(pI2Cx,I2C_FLAG_TXE));
	while(!I2C_GetFlagStatus(pI2Cx,I2C_FLAG_BTF));
	//8.generate the stop condition
	I2C_GenerateStoptCondition(pI2Cx);
}

void I2C_MasterReceiveData(I2C1_RedDef_t*pI2Cx,uint8_t *pRxBuffer,uint8_t len,uint8_t SlaveAddr,uint8_t *count){
	//1.generate the start condition
	I2C_GenerateStartCondition(pI2Cx);
	//2.confirm the start condition was completed by SB flag
	while(!I2C_GetFlagStatus(pI2Cx,I2C_FLAG_SB ));
	//3.send the address of slave + R/nW
	I2C_ExecuteAddressPhaseRead(pI2Cx,SlaveAddr);
	//4.confirm address phase was completed by ADDR flag
	while(!I2C_GetFlagStatus(pI2Cx,I2C_FLAG_ADDR ));
	//procedure to read only 1 byte from slave
	if(len==1){
		//clear the ADDR fag
		I2C_ClearADDRFlag(pI2Cx);
		//disable ack
		I2C_ManageAcking(pI2Cx,DISABLE);
		// wait until RxNE=1
		while(!I2C_GetFlagStatus(pI2Cx,I2C_FLAG_RXNE ));
		//generate the stop condition
		I2C_GenerateStoptCondition(pI2Cx);
		//read data from data resgister into buffer
		*pRxBuffer=pI2Cx->DR;
	}
	if(len>1){
		//clear the ADDR flag
		I2C_ClearADDRFlag(pI2Cx);
		//read the data until len become zezo
		for(uint8_t i=len;i>0;i--){
			// wait until RxNE=1
		    while(!I2C_GetFlagStatus(pI2Cx,I2C_FLAG_RXNE ));
		    //if last 2 byte are remaining
		    if(i==2){
		    	//disable ack
		    	I2C_ManageAcking(pI2Cx,DISABLE);
		    	//generate the stop condition
		    	I2C_GenerateStoptCondition(pI2Cx);
		    }
		    //read data from data resgister into buffer
		    		*pRxBuffer=pI2Cx->DR;
		    // increase the buffer's adddress
		    	     pRxBuffer++;
		    	     (*count)++;
		}
	}
	//re-enable ACKing
	I2C_ManageAcking(pI2Cx,ENABLE);
}

int main(void)
{
  //init
	Init();
  //enable the I2C peripheral
  I2C_PeripheralControl(pI2C1,ENABLE);

  // ACK on
  I2C_ManageAcking(pI2C1,ENABLE);

  //Create an array containing data
  uint8_t AHT10_data[6]={0,0,0,0,0,0};

  uint8_t CheckBuffer;
  uint32_t AHT10_ADC_Raw;
  float AHT10_Temperature;
  while(1){
	  uint8_t count=0;
	 // Measure and save 10 values from AHT10
	  for(uint8_t i=0;i<10;i++){
		      CheckBuffer=0;
		 	  AHT10_ADC_Raw&=(~(0xffff));
		 	  AHT10_Temperature=0;
		 	  I2C_MasterSendData(pI2C1,AHT10_command,3,0x38);
		 	  delay();
		 	  I2C_MasterReceiveData(pI2C1,AHT10_data,6,0x38,&CheckBuffer);
		 	  while(!(CheckBuffer == 6));
		 	  //convert to Temperature C degrees
		 	  AHT10_ADC_Raw=((((uint32_t)AHT10_data[3]&15)<<16) | ((uint32_t)AHT10_data[4]<<8) |((uint32_t)AHT10_data[5]));
		 	  AHT10_Temperature=(float)(AHT10_ADC_Raw*200.00/1048576.00-50.00);
		 	  array[i]=AHT10_Temperature;
	 }
	 //Compare with the temperature mark 10 times
	 for(uint8_t i=0;i<10;i++){
		 if(array[i]>25.3){
			 count++;
		 }
	 }
	 //logic
	 if(count>=8){
		 GPIO_FanOn(pGPIOB);
	 }
	 else{
		 GPIO_FanOff(pGPIOB);
	 }
  }

	//GPIO_FanOn(pGPIOB);

	for(;;);
}
